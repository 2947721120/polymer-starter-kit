<style>
  .desktop-x-small-landscape:after,
  .desktop-x-small:after,
  .desktop-small-landscape:after,
  .desktop-small:after,
  .desktop-medium-landscape:after,
  .desktop-medium:after,
  .desktop-large:after,
   .desktop-xlarge:after {
    position: absolute;
    bottom: 0;
    right: 0;
    content: "";
    z-index: 1000;
    white-space: nowrap;
    color: white;
    text-align: center;
    font-family: arial;
    font-size: 12px;
    line-height: 32px;
    padding: 0 20px;
    background-color: rgba(0, 0, 0, 0.5);
  }

  .desktop-x-small-landscape:after {
    content: "desktop-x-small-landscape";
  }

  .desktop-x-small:after {
    content: "desktop-x-small";
  }

  .desktop-small-landscape:after {
    content: "desktop-small-landscape";
  }

  .desktop-small:after {
    content: "desktop-small";
  }

  .desktop-medium-landscape:after {
    content: "desktop-medium-landscape";
  }

  .desktop-medium:after {
    content: "desktop-medium";
  }

  .desktop-large:after {
    content: "desktop-large";
  }

  .desktop-xlarge:after {
    content: "desktop-xlarge";
  }
</style><script>
(function() {

  var sharedStyle;
  var selectorsInSharedStyle = {};
  var selector = '.has-grid:not(.no-gridify)';
  var elementsWithGrid = new Map();
  var pressedEventHandler;

  function invertColor(rgb) {
    var c = rgb.replace(/rgba?|\(|\)|\s/gi, '').split(',');
    return [
      255 - c[0],
      255 - c[1],
      255 - c[2]
    ];
  }

  function setCSSRule(selector, propStr) {
    if (!sharedStyle) {
      sharedStyle = document.createElement('style');
      document.head.appendChild(sharedStyle);
    }
    if (selector in selectorsInSharedStyle) {
      return;
    }

    selectorsInSharedStyle[selector] = true;
    sharedStyle.sheet.insertRule( selector + ' { ' + propStr + '}', 0);
  }

  function showGrid(element) {
    var props = element._computeStyleProperties();
    var computedStyles = window.getComputedStyle(element);
    var bgcolor = computedStyles['background-color'] || 'rgb(255, 255, 255)';
    var color = invertColor(bgcolor);
    var columns = props['--grid-columns'];
    var columnWidth = props['--grid-column-width'];
    var gutter = props['--grid-gutter'];
    var colNumber = color[0] << 16 | color[1] << 8 | color[0];
    var className = 'grid_' + columns + '_' + gutter + '_' + colNumber;
    var hint, propStr = '';

    if (columnWidth) {
      className = 'grid_' + columnWidth + '_' + gutter + '_' + colNumber;
      hint = 'column width: ' + columnWidth + ', gutter: ' + gutter;
    } else {
      className = 'grid_' + columns + '_' + gutter + '_' + colNumber;
      hint = 'columns: ' + columns + ', gutter: ' + gutter;
    }

    if (elementsWithGrid.has(element)) {
      if (elementsWithGrid.get(element) === className) {
        return;
      } else {
        element.classList.remove(elementsWithGrid.get(element));
      }
    }

    if (!(className in selectorsInSharedStyle)) {
      propStr += 'content: "";';
      propStr += 'position: absolute;';
      propStr += 'top: 0;';
      propStr += 'left: 0;';
      propStr += 'z-index: 1;';
      propStr += 'right: 0;';
      propStr += 'bottom: 0;';
      propStr += 'opacity: 0.3;';
      propStr += 'pointer-events: none;';
      propStr += 'background: ';

      if (columnWidth) {
        propStr += embedSVG(buildSvg(color, 1, gutter, '100%'))
        propStr += ' repeat ';
        propStr += ';';
        propStr += 'background-size: calc(' + columnWidth + ' + ' + gutter + ') 100px';

      } else {
        propStr += embedSVG(buildSvg(color, columns, gutter, '100%'))
        propStr += ' repeat-y';
        propStr += ',';
        propStr += embedSVG(buildSvg(color, 1, gutter, gutter));
        propStr += ' right top repeat-y';
        propStr += ';';
        propStr += 'background-size: calc(100% - ' + gutter + ') 100px, ' + gutter + ' 100px;';
      }

      setCSSRule('.' + className + ':after', propStr);

      // position: relative will allow to position the overlay
      if (computedStyles.position === 'static') {
       setCSSRule('.' + className , 'position: relative;');
      }
      // fade in
      propStr = 'opacity: 0.5;';
      propStr += 'content: "' + hint + '";';
      propStr += 'color: white;';
      propStr += 'font-size: 10px;';
      propStr += 'font-weight: bold;';
      propStr += 'text-shadow: 0 0 1px black;';
      propStr += 'white-space:nowrap;';

      setCSSRule('.' + className + ':hover:after', propStr);
    }

    element.classList.add(className);
    elementsWithGrid.set(element, className);
  }

  function hideGrid(element) {
    if (elementsWithGrid.has(element)) {
      element.classList.remove(elementsWithGrid.get(element));
      elementsWithGrid.delete(element);
    }
  }

  function embedSVG(svg) {
    return 'url(\'data:image/svg+xml;utf8,' + svg + '\')';
  }

  function buildSvg(color, columns, gutter, width) {

    gutter = parseInt(gutter, 10);
    color = 'rgb(' + color[0] + ', ' + color[1] + ', ' + color[2] + ')';

    var columnWidth = 100 / columns;
    var halfGutter = gutter / 2;
    var negHalfGutter = -halfGutter;
    var svg = '';

    svg += '<svg xmlns="http://www.w3.org/2000/svg" width="' + width +'" height="100" version="1.1">';
    svg += '<g transform="translate(' + halfGutter + ')">';

    for (var column = 0; column < columns; column++) {
      svg += '<rect transform="translate(' + (negHalfGutter) + ')" ';
      svg += 'width="' + gutter + '" ';
      svg += 'height="100%" ';
      svg += 'x="' + (column * columnWidth) + '%" ';
      svg += 'y="0" ';
      svg += 'fill="' + color + '" ';
      svg += 'stroke-width="0" ';
      svg += '/>';
    }

    svg += '</g>';
    svg += '</svg>';

    return svg;
  }

  function hasParentWithGrid(node) {
    while (node) {
      if (!(node instanceof HTMLElement)) {
        return null;
      }
      if (node.classList.contains('has-grid') || node.tagName == 'X-GRID') {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }

  document.addEventListener('mousedown', function(e) {
    if (!pressedEventHandler && e.button !== 2) {
      pressedEventHandler = setTimeout(function() {
         var elemWithGrid = hasParentWithGrid(e.target);
      if (elemWithGrid) {
        if (elementsWithGrid.has(elemWithGrid)) {
          hideGrid(elemWithGrid);
        } else {
          showGrid(elemWithGrid);
        }
      }
    }, 150);
   }
  }, false);

  document.addEventListener('mouseup', function(e) {
    clearInterval(pressedEventHandler);
    pressedEventHandler = 0;
  }, false);

  document.addEventListener('breakpointChanged', function(e) {
    elementsWithGrid.forEach(function(selector, element) {
      showGrid(element);
    });
  }, false);

})();
</script>